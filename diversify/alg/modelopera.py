# -*- coding: utf-8 -*-
"""modelopera

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Q-I--gA94AgVaUYAfhmBzkidYlUg7dZB
"""

# Copyright (c) Microsoft Corporation.
# Licensed under the MIT License.

import torch
from network import act_network

def get_fea(args):
    if hasattr(args, 'use_gnn') and args.use_gnn:
        from gnn.temporal_gcn import TemporalGCN

        # Default values if not present
        input_dim = 8  # EMG channels
        hidden_dim = getattr(args, 'gnn_hidden_dim', 32)
        output_dim = getattr(args, 'gnn_output_dim', 128)

        net = TemporalGCN(input_dim, hidden_dim, output_dim)
        net.in_features = output_dim  # Needed for downstream bottleneck

        return net
    else:
        net = act_network.ActNetwork(args.dataset)
        return net


def accuracy(network, loader, weights, usedpredict='p'):
    correct = 0
    total = 0
    weights_offset = 0

    network.eval()
    with torch.no_grad():
        for data in loader:
            x = data[0].cuda().float()
            y = data[1].cuda().long()
            if usedpredict == 'p':
                p = network.predict(x)
            else:
                p = network.predict1(x)
            if weights is None:
                batch_weights = torch.ones(len(x))
            else:
                batch_weights = weights[weights_offset:
                                        weights_offset + len(x)]
                weights_offset += len(x)
            batch_weights = batch_weights.cuda()
            if p.size(1) == 1:
                correct += (p.gt(0).eq(y).float() *
                            batch_weights.view(-1, 1)).sum().item()
            else:
                correct += (p.argmax(1).eq(y).float() *
                            batch_weights).sum().item()
            total += batch_weights.sum().item()
    network.train()
    return correct / total
